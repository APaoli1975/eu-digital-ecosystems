---
title: "Funding ≠ Outcomes: Why Policy Design Matters — Four EU Cities"
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 2
  pdf:
    toc: true
    number-sections: false
execute:
  echo: false
  warning: false
  message: false
editor: source
params:
  year_min: 2000
  year_max: 2021
  min_years_per_city: 5
---

## 0) Setup & Data Load

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(readr)
library(stringr)
library(forcats)
theme_set(theme_minimal(base_size = 12))

# ---- guard: correct pipeline order & file ----
fp <- "data_clean/analysis_ready_4cities_with_funding.csv"
if (!file.exists(fp)) {
  stop(
    "Missing file: ", fp, "\n",
    "Run: source('scripts/01_pull_eurostat.R');\n",
    "     source('scripts/02_pull_oecd.R');\n",
    "     source('scripts/03_build_indicators.R');\n",
    "     source('scripts/03_merge_panel.R');\n",
    "     source('scripts/04_fetch_funding.R');\n",
    "     source('scripts/05_merge_funding.R')",
    call. = FALSE
  )
}

dat0 <- readr::read_csv(fp, show_col_types = FALSE)

# Core outcome indicators we actually have in the current panel
core_inds <- c("HighTech_Employment_regional",
               "HighTech_patents_regional",
               "GERD_regional")

# Nice city ordering and groups
city_levels <- c("Tallinn","Barcelona","Athens","Lisbon")
city_group  <- tibble::tibble(
  city = city_levels,
  group = c("Success","Success","Poor","Poor")
)

# Window controls
year_min <- params$year_min
year_max <- params$year_max
min_years <- params$min_years_per_city

# A tiny helper for percent labels
pct <- function(x, digits = 0) paste0(round(100*x, digits), "%")
```

**Data loaded** from `data_clean/analysis_ready_4cities_with_funding.csv`.  
**Cities:** `r paste(sort(unique(dat0$city)), collapse = ", ")`  
**Window:** `r year_min`–`r year_max` (adaptive in some charts if needed).

---

## 1) Guardrails & Cleaning

*Method.* We standardise names, keep the four cities, clip the window, and drop obviously empty rows. We keep only the **core** Eurostat outcomes for the comparison sections, while the **funding** variables are used later contextually.

```{r}
dat <- dat0 %>%
  mutate(city = factor(city, levels = city_levels)) %>%
  filter(city %in% city_levels, year >= year_min, year <= year_max)

# Keep only the columns we’ll use downstream (defensive)
keep_cols <- c("city","year","indicator","value",
               # FUA macro (may be NA for some spans)
               "gdp","empw","lab_prod",
               # funding & intensities (added in 05)
               "eu_funding","funding_to_gdp","funding_per_emp")
keep_cols <- intersect(keep_cols, names(dat))
dat <- dat %>% select(all_of(keep_cols))

# Split into core outcomes and funding panel for clarity
core_long <- dat %>% filter(indicator %in% core_inds) %>%
  filter(!is.na(value))

fund_long <- dat %>%
  select(city, year, eu_funding, funding_to_gdp, funding_per_emp, lab_prod) %>%
  distinct()

# Simple coverage table for sanity
cov_tbl <- core_long %>%
  group_by(city, indicator) %>%
  summarise(years = n_distinct(year),
            non_na = n_distinct(year[!is.na(value)]),
            completeness = ifelse(years == 0, 0, non_na/years),
            .groups = "drop")

if (nrow(core_long) == 0) {
  stop("No core outcomes in the selected window. Try widening the window or re-running the pipeline.")
}
```

*Reading.* We will only draw plots that have sufficient data to be interpretable; otherwise we annotate the limitation.

---

## 2) Signal, not noise — indexed momentum

*Method.* For each core outcome, we index each city’s series to **100 at the first non-missing year** in the window. This removes scale effects and highlights **momentum**.

```{r}
index_to_100 <- function(df, value_col = "value") {
  # df: city, indicator, year, value
  df %>%
    arrange(indicator, city, year) %>%
    group_by(indicator, city) %>%
    mutate(
      .base = suppressWarnings(first(na.omit(.data[[value_col]]))),
      idx   = ifelse(is.finite(.base) & .base != 0,
                     .data[[value_col]]/.base * 100, NA_real_)
    ) %>%
    ungroup()
}

core_idx <- index_to_100(core_long, "value")

# Only plot if enough obs (>= 5 years per city-indicator)
ok_plot <- core_idx %>%
  group_by(indicator, city) %>%
  summarise(n = sum(!is.na(idx)), .groups = "drop") %>%
  filter(n >= min_years)

core_idx_ok <- core_idx %>%
  semi_join(ok_plot, by = c("indicator","city"))

if (nrow(core_idx_ok) > 0) {
  p_idx <- ggplot(core_idx_ok, aes(year, idx, color = city, group = city)) +
    geom_line(linewidth = 1) +
    geom_point(size = 1.7) +
    facet_wrap(~ indicator, ncol = 1, scales = "free_y") +
    labs(title = "Indexed momentum (base = 100 at first available year)",
         x = NULL, y = "Index (base=100)",
         caption = "Core outcomes: HighTech Employment, HighTech Patents, GERD. Window clipped to data availability.")
  print(p_idx)
} else {
  cat("No indicator × city has ≥", min_years, "years within the window for indexed plotting.\n")
}
```

*Reading.* Where coverage allows, **Tallinn/Barcelona** show sustained momentum; **Athens/Lisbon** flatter and more volatile. This suggests **money is not sufficient** without effective policy design.

---

## 3) Pooled contrast — Success vs Poor

*Method.* We create two groups (Success = Tallinn, Barcelona; Poor = Athens, Lisbon), average within group, and compare **indexed paths**. This reduces noise; treat as descriptive, not causal.

```{r}
pooled <- core_long %>%
  inner_join(city_group, by = "city") %>%
  group_by(group, indicator, year) %>%
  summarise(value = mean(value, na.rm = TRUE), .groups = "drop")

pooled_idx <- index_to_100(pooled, "value")

ok_pooled <- pooled_idx %>%
  group_by(group, indicator) %>%
  summarise(n = sum(!is.na(idx)), .groups = "drop") %>%
  filter(n >= min_years)

pooled_idx_ok <- pooled_idx %>% semi_join(ok_pooled, by = c("group","indicator"))

if (nrow(pooled_idx_ok) > 0) {
  p_pool <- ggplot(pooled_idx_ok, aes(year, idx, color = group, group = group)) +
    geom_line(linewidth = 1.1) +
    geom_point(size = 1.8) +
    facet_wrap(~ indicator, ncol = 1, scales = "free_y") +
    scale_color_manual(values = c("Success"="#1b9e77","Poor"="#d95f02")) +
    labs(title = "Pooled contrast (indexed): Success vs Poor",
         x = NULL, y = "Index (base=100)", color = NULL)
  print(p_pool)
} else {
  cat("Pooled series do not meet minimum coverage for plotting.\n")
}
```

*Reading.* Success generally outperforms Poor; **timing** and **slope** of improvements differs, hinting at process quality rather than funding volume alone.

---

## 4) Funding intensity vs outcomes

*Method.* We use annual `eu_funding` and two intensities (`funding_to_gdp`, `funding_per_emp`) from the merged panel, and relate them to macro **lab_prod** (when available). We keep charts clean and only draw when data exist.

```{r}
# Funding levels (log scale if range is wide)
f1 <- fund_long %>% filter(!is.na(eu_funding))
if (nrow(f1) > 0) {
  p_funding <- ggplot(f1, aes(year, eu_funding, color = city)) +
    geom_line(linewidth = 1) + geom_point(size = 1.6) +
    scale_y_continuous(labels = scales::label_number_si()) +
    labs(title = "EU Payments (annual)", x = NULL, y = "EUR (SI units)")
  print(p_funding)
} else cat("No eu_funding values in window.\n")

# Funding intensity to GDP
f2 <- fund_long %>% filter(!is.na(funding_to_gdp))
if (nrow(f2) > 0) {
  p_ftg <- ggplot(f2, aes(year, funding_to_gdp, color = city)) +
    geom_line(linewidth = 1) + geom_point(size = 1.6) +
    labs(title = "Funding intensity: EU funding / GDP", x = NULL, y = "Share")
  print(p_ftg)
} else cat("No funding_to_gdp values in window.\n")

# Cross-plot: funding intensity vs productivity
f3 <- fund_long %>% filter(!is.na(funding_to_gdp) & !is.na(lab_prod))
if (nrow(f3) > 0) {
  p_cross <- ggplot(f3, aes(funding_to_gdp, lab_prod, color = city)) +
    geom_point(alpha = 0.7, size = 2) +
    geom_smooth(method = "lm", se = FALSE, linewidth = 0.8, color = "grey40") +
    labs(title = "Does higher funding intensity align with productivity?",
         x = "Funding / GDP", y = "Labour productivity (FUA macro)")
  print(p_cross)
} else cat("No joint coverage for funding_to_gdp & lab_prod.\n")
```

*Reading.* Funding size and intensity in **Athens/Lisbon** does **not** translate into superior outcomes. This supports the thesis: **funding alone is insufficient**.

---

## 5) A small, legible scoreboard (latest comparable year)

*Method.* For each variable below, pick the **latest year** with ≥3 cities non‑missing. Z‑score within that year to compare positions.

```{r}
# Assemble scoreboard variables
sb_vars <- list(
  outcomes = c("HighTech_Employment_regional",
               "HighTech_patents_regional",
               "GERD_regional"),
  intensities = c("funding_to_gdp","funding_per_emp")
)

# Outcomes long
sb_out <- core_long %>% filter(indicator %in% sb_vars$outcomes) %>%
  select(city, year, indicator, value)

# Funding/intensity long (melt)
sb_fund <- fund_long %>%
  select(city, year, funding_to_gdp, funding_per_emp) %>%
  pivot_longer(cols = c(funding_to_gdp, funding_per_emp),
               names_to = "indicator", values_to = "value") %>%
  filter(!is.na(value))

sb_all <- bind_rows(sb_out, sb_fund)

# For each indicator, take the latest year with >=3 cities present
latest_ok <- sb_all %>%
  group_by(indicator, year) %>%
  summarise(n_city = n_distinct(city[!is.na(value)]), .groups = "drop_last") %>%
  filter(n_city >= 3) %>%
  summarise(latest = max(year), .groups = "drop")

sb_take <- sb_all %>%
  inner_join(latest_ok, by = "indicator") %>%
  filter(year == latest)

if (nrow(sb_take) > 0) {
  sb_z <- sb_take %>%
    group_by(indicator, year) %>%
    mutate(z = ifelse(sd(value, na.rm = TRUE) > 0,
                      (value - mean(value, na.rm = TRUE)) / sd(value, na.rm = TRUE),
                      NA_real_)) %>%
    ungroup()

  p_sb <- ggplot(sb_z, aes(x = fct_reorder(city, z, .fun = mean, .na_rm = TRUE),
                           y = z, fill = city)) +
    geom_col(width = 0.7) +
    facet_wrap(~ indicator, ncol = 1, scales = "free_y") +
    coord_flip() +
    labs(title = "Scoreboard — latest comparable year (z‑scores within indicator)",
         subtitle = paste0("Year varies by indicator; requires ≥3 cities non‑missing"),
         x = NULL, y = "z‑score") +
    theme(legend.position = "none")
  print(p_sb)
} else {
  cat("No indicator has ≥3 cities in a common latest year — scoreboard skipped.\n")
}
```

*Reading.* The **snapshot** mirrors the story above: **Success** cities tend to dominate in outcomes, despite similar or lower funding intensities at times.

---

## 6) Policy interpretation — why the divergence?

*Quant signals.*  
(1) **Indexed momentum**: Tallinn/Barcelona sustain gains; Athens/Lisbon flatter paths.  
(2) **Funding intensity**: not aligned with superior outcomes in the poor group.  
(3) **Scoreboard**: compresses to a persuasive snapshot without over‑plotting.

*Policy reading.*  
- **Success**: coherent strategies (talent, demand‑pull, procurement, continuity, capable delivery units).  
- **Poor**: fragmented initiatives, weak continuity, limited delivery capacity — funds are spent, but not **translated** into ecosystem outcomes.

*Next steps.*  
Add short, dated timelines for EU/regional instruments and align them to observed **inflection points** in the indexed series.

---

## Appendix — Coverage table (for reviewers)

```{r}
cov_tbl %>%
  arrange(indicator, city) %>%
  knitr::kable()
```

